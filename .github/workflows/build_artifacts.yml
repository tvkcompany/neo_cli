name: Build Artifacts

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
        description: "Version number for the release (e.g. 1.6.5 or 1.7.1-beta.3)"
    secrets:
      webhookUrl:
        required: true
        description: "Discord webhook URL for notifications"

jobs:
  notify-start:
    uses: ./.github/workflows/send_discord_message.yml
    with:
      message: "üèóÔ∏è Starting build for version `${{ inputs.version }}`..."
    secrets:
      webhookUrl: ${{ secrets.webhookUrl }}

  build:
    name: Build (${{ matrix.os }}-${{ matrix.arch }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          # Linux builds (amd64 and arm64)
          - os: ubuntu-latest
            arch: amd64
            platform: linux
          - os: ubuntu-latest
            arch: arm64
            platform: linux
          # Windows (amd64 only as arm64 not yet fully supported by Dart)
          - os: windows-latest
            arch: amd64
            platform: windows
          # macOS (universal binary - works on both Intel and Apple Silicon)
          - os: macos-latest
            arch: universal
            platform: macos

    steps:
      - uses: actions/checkout@v4

      - name: Get SDK version from pubspec.yaml (Unix)
        if: runner.os != 'Windows'
        id: sdk-version-unix
        run: |
          SDK_VERSION=$(grep "sdk:" pubspec.yaml | sed -E 's/.*\^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          echo "version=$SDK_VERSION" >> $GITHUB_OUTPUT

      - name: Get SDK version from pubspec.yaml (Windows)
        if: runner.os == 'Windows'
        id: sdk-version-windows
        run: |
          $content = Get-Content pubspec.yaml
          $sdkLine = $content | Select-String -Pattern "sdk:"
          $version = $sdkLine -replace '.*\^([0-9]+\.[0-9]+\.[0-9]+).*','$1'
          echo "version=$version" >> $env:GITHUB_OUTPUT

      - name: Setup Dart SDK
        uses: dart-lang/setup-dart@v1
        with:
          sdk: ${{ steps.sdk-version-unix.outputs.version || steps.sdk-version-windows.outputs.version }}

      - name: Install dependencies
        run: dart pub get

      - name: Set up QEMU for ARM64 builds
        if: matrix.arch == 'arm64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set output filename (Unix)
        if: runner.os != 'Windows'
        id: set-filename-unix
        run: |
          VERSION="${{ inputs.version }}"
          # Replace dots with underscores in version for filename safety
          SAFE_VERSION=$(echo $VERSION | tr '.' '_')
          if [ "${{ matrix.platform }}" = "windows" ]; then
            echo "output_name=neo_cli_${{ matrix.platform }}_${{ matrix.arch }}_${SAFE_VERSION}.exe" >> $GITHUB_OUTPUT
          else
            echo "output_name=neo_cli_${{ matrix.platform }}_${{ matrix.arch }}_${SAFE_VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Set output filename (Windows)
        if: runner.os == 'Windows'
        id: set-filename-windows
        run: |
          $VERSION = "${{ inputs.version }}"
          # Replace dots with underscores in version for filename safety
          $SAFE_VERSION = $VERSION -replace '\.','_'
          if ("${{ matrix.platform }}" -eq "windows") {
            # For the executable itself
            echo "output_name=neo_cli_${{ matrix.platform }}_${{ matrix.arch }}_${SAFE_VERSION}.exe" >> $env:GITHUB_OUTPUT
            # For the archive name (without .exe)
            echo "archive_name=neo_cli_${{ matrix.platform }}_${{ matrix.arch }}_${SAFE_VERSION}" >> $env:GITHUB_OUTPUT
          } else {
            echo "output_name=neo_cli_${{ matrix.platform }}_${{ matrix.arch }}_${SAFE_VERSION}" >> $env:GITHUB_OUTPUT
          }

      - name: Build executable (Unix)
        if: runner.os != 'Windows'
        run: |
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            docker run --rm --platform linux/arm64 --volume "${PWD}:/work" --workdir /work dart:stable /bin/sh -c "dart pub get && dart compile exe bin/neo_cli.dart -o ${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}"
          else
            dart compile exe bin/neo_cli.dart -o ${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}
          fi

      - name: Build executable (Windows)
        if: runner.os == 'Windows'
        run: |
          dart compile exe bin/neo_cli.dart -o ${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}

      - name: Create archive (Unix)
        if: runner.os != 'Windows'
        run: |
          tar czf "${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}.tar.gz" "${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}"

      - name: Create archive (Windows)
        if: runner.os == 'Windows'
        run: |
          tar -czf "${{ steps.set-filename-windows.outputs.archive_name }}.tar.gz" "${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}"

      - name: Generate checksum
        run: |
          if [ "${{ runner.os }}" = "Windows" ]; then
            FILENAME="${{ steps.set-filename-windows.outputs.archive_name }}.tar.gz"
            echo "$FILENAME" > checksum_filename.txt
            sha256sum "$FILENAME" > checksum.txt
          else
            FILENAME="${{ steps.set-filename-unix.outputs.output_name || steps.set-filename-windows.outputs.output_name }}.tar.gz"
            echo "$FILENAME" > checksum_filename.txt
            sha256sum "$FILENAME" > checksum.txt
          fi

      - name: Upload checksum
        uses: actions/upload-artifact@v4
        with:
          name: checksum-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            checksum.txt
            checksum_filename.txt
          retention-days: 1

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ runner.os == 'Windows' && steps.set-filename-windows.outputs.archive_name || steps.set-filename-unix.outputs.output_name }}
          path: |
            ${{ runner.os == 'Windows' && format('{0}.tar.gz', steps.set-filename-windows.outputs.archive_name) || format('{0}.tar.gz', steps.set-filename-unix.outputs.output_name) }}
          retention-days: 1

  combine-checksums:
    needs: [build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all checksums
        uses: actions/download-artifact@v4
        with:
          pattern: checksum-*
          path: checksums
          merge-multiple: true

      - name: Combine checksums
        run: |
          # Convert version to safe version for filename
          SAFE_VERSION=$(echo "${{ inputs.version }}" | tr '.' '_')

          echo "# neo_cli ${{ inputs.version }} checksums" > neo_cli_${SAFE_VERSION}_checksums.txt
          echo "# Generated on $(date -u)" >> neo_cli_${SAFE_VERSION}_checksums.txt
          echo "" >> neo_cli_${SAFE_VERSION}_checksums.txt

          # Process each platform's checksum
          for dir in checksums/checksum-*; do
            if [ -f "$dir/checksum.txt" ] && [ -f "$dir/checksum_filename.txt" ]; then
              HASH=$(cat "$dir/checksum.txt" | cut -d ' ' -f1)
              FILENAME=$(cat "$dir/checksum_filename.txt")
              echo "$HASH  $FILENAME" >> neo_cli_${SAFE_VERSION}_checksums.txt
            fi
          done

      - name: Upload combined checksums
        uses: actions/upload-artifact@v4
        with:
          name: checksums
          path: neo_cli_*_checksums.txt
          retention-days: 1

  notify-result:
    needs: [build, combine-checksums]
    if: always()
    uses: ./.github/workflows/send_discord_message.yml
    with:
      message: |
        ${{ 
          needs.build.result == 'success'
          && format('‚úÖ Successfully built artifacts for version `{0}`!', inputs.version)
          || format('‚ùå Failed to build artifacts for version `{0}`. Please check the logs.', inputs.version)
        }}
    secrets:
      webhookUrl: ${{ secrets.webhookUrl }}
